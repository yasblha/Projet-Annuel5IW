---
description: >
alwaysApply: false
---
## Architecture

- Microservices written in **NestJS** with a **Vue 3** frontend (README).
- **Domain-Driven Design**, **CQRS**, repository and use‑case patterns.
- Services communicate by **RabbitMQ** events.
- Database access through **Sequelize** models and migrations.

### Standard Project Layout
services/<name>-service/
src/
application/ # Usecases, services, validators
domain/ # Entités métier et erreurs
infrastructure/ # Adapters, config, events, guards, logger
main.ts # Entrée NestJS
Database/ # Modèles, migrations, repositories partagés
frontend/src/ # Vue components, views, stores, services

markdown
Copier

## Coding Standards

- **TypeScript strict mode** with ESLint/Prettier.
- Prettier uses *single quotes* and *trailing commas* (`.prettierrc`).
- `.eslintrc.js` extends `@typescript-eslint/recommended` and `plugin:prettier/recommended`.
- Organize backend logic into use cases with repositories for data access.

## Commit & PR Guidelines

- Use conventional commit messages (feat:, fix:, docs:, refactor:, test:…).
- Keep commits focused; describe the implemented change clearly.
- Provide a descriptive PR body referencing the feature or fix.

## Development Workflow

1. Install dependencies: `npm install`.
2. Implement code in the corresponding microservice or frontend module.
3. Run `npm run lint` and `npm run test` (plus `npm run test:e2e` if available).
4. Commit using conventional messages.
5. Open a PR with a clear summary.

## Backend

- Each microservice replicates the structure shown above.
- Migrations and models live in `Database/` or in each service’s `src/infrastructure/database`.
- Use NestJS modules to inject services (e.g., a `NumberGenerator` service for contract numbering).
- Keep business logic in `application/usecases`, invoked via controllers.

## Frontend

- Vue 3 with `<script setup lang="ts">`.
- Components reside under `src/components`; pages in `src/views`; API calls in `src/services`.
- Use Pinia stores in `src/stores`.
- Tailwind for styling; keep components small and focused.

## Configuration & Environment

- Example variables in README show default ports and env names (Postgres, RabbitMQ, JWT, etc.).
- Use `Docker Compose` to run all services locally (`docker compose up -d --build`).

## Testing & Quality

- Unit tests via `npm run test`.
- Integration (e2e) tests via `npm run test:e2e` where defined.
- Linting with `npm run lint`.
- Build with `npm run build`.

## Example Numbering Feature (Contrat-Service)

- Implement a `NumberGenerator` service to create contract numbers (`C-<zone>-<year>-<seq>`).
- Inject the service into `ContratModule` and call it in use cases (e.g., finalize contract).
- Optionally generate meter IDs with `M-<zone>-<type>-<serial>`.

Follow these rules to maintain coherence across the backend microservices and the Vue frontend while contributing new features or fixes.

## Schéma d’identification par zone
mermaid

flowchart LR
    A[Zone<br>(Agence ou INSEE)] -->|préfixe| ID_CONTRAT
    B[Année courante<br>(2 ou 4 chiffres)] -->|suffixe 1| ID_CONTRAT
    C[Compteur incrémental<br>(00001-99999)] -->|suffixe 2| ID_CONTRAT

    A -->|préfixe| ID_COMPTEUR
    D[Type compteur<br>(E = eau / A = assain.)] -->|suffixe 1| ID_COMPTEUR
    E[Numéro série constructeur<br>(6-8 car.)] -->|suffixe 2| ID_COMPTEUR

## Tableau — Format des identifiants
Objet	Pattern proposé	Exemple	Unicité garantie par
Contrat	C-<ZONE>-<YY>-<NNNNN>	C-TLS-25-00432	index unique sur (zone, année, n°)
Compteur	M-<ZONE>-<TYP>-<SERIE>	M-TLS-E-0876543	clé unique ≈ serial actuel
Zone (<ZONE>)	Code court (2-4 letras) : agence ou code INSEE commune	TLS (Toulouse)	table agencies(code)
Année (<YY>)	Deux chiffres (année de création contrat)	25 → 2025	—
Compteur incrémental (<NNNNN>)	Compteur séquentiel par zone+année, remisé chaque 1ᵉʳ janv.	00432	séquence SQL par (zone, année)
Type (<TYP>)	E eau, A assainissement, EA mixte	E	énumération DB
Série constructeur (<SERIE>)	N° gravé sur compteur, zéro-pad si besoin	0876543	lecture terrain / IoT

## Bilan explicatif
Lisibilité immédiate :
En voyant C-TLS-25-00432, on sait qu’il s’agit du contrat n° 432 ouvert en 2025 sur la zone Toulouse.

Découplage faible : la logique « zone → préfixe » vit dans une table agencies ; si une agence fusionne, on crée un nouvel alias sans casser l’historique.

Unicité robuste :

Contrat : index composite (zone, year, seq) ou UUID interne + champ numero human-friendly.

Compteur : on conserve serial constructeur pour éviter doublon matériel.

Scalabilité : 99 999 contrats maximum par zone et par an ; suffit pour > 95 k /déclarations/an/zone. Si besoin, passer le compteur à 6 chiffres.

## Implémentation simple :

SQL sequence par (zone, année) : CREATE SEQUENCE seq_tls_25 INCREMENT 1 START 1;

## Trigger avant insert qui construit numero.

Collision inter-zones impossible : le préfixe zone assure partition logique, idéal pour sharding ou filtrage RGPD.

Front-end : pas besoin de générer l’ID côté client ; l’API renvoie numero après création et le front ne fait qu’afficher.

Ce format est donc métier-friendly tout en restant techniquement fiable pour ton micro-service contrat-service.


---
